[TOP](../README.md)  
前: [コンテナの起動](./container-run.md)  
前: [どこでも同じものが動くということ](./container-feature-reproducibility.md)（時間ある人向け）  
次: [コンテナにファイルシステムをマウント](./container-volume.md)  

---

# コンテナへのアクセス

**ここから前に出た手順のコマンドは省略します。自分で調べながら進めてみてください。**

コンテナはホスト内の隔離されたネットワーク（デフォルトではbridgeというネットワーク）で動いています。同一ホスト内のコンテナはこのネットワークで通信が可能です。しかし、これだとホスト外からアクセスすることができません。dockerではコンテナを起動する時に隔離ネットワークとホストOSを繋ぐことができます。

1. ``nginx:1.19.2``のイメージを使いコンテナをバックグラウンドで実行してください。

2. 作成したコンテナに対して``curl localhost``の追加コマンドを発行してください。**Welcome to nginx**が``表示される``ことを確認してください。

3. ホストOSで同じく``curl localhost``を実行してください。**Welcome to nginx**が``表示されないこと``を確認してください。
   
このように、ホストOS（隔離ネットワーク外）からはコンテナにアクセスできていません。次にコンテナの起動コマンドでホストOSの任意のポートとコンテナを接続し、隔離ネットワーク外からアクセスできるようにします。

4. ``nginx:1.19.2``のイメージを使いコンテナをバックグラウンドで実行してください。コンテナの80をホストOSの8080に接続してください。接続は``docker runコマンドのオプション``で指定します。やり方は[日本語マニュアル](http://docs.docker.jp/engine/reference/commandline/run.html#p-expose)を参考にしてください。

5. コンテナの一覧を確認してください。また、``PORTS``に``0.0.0.0:8080->80/tcp``と表示されていることを確認してください。このように表示されればホストOSの8080がコンテナの80に繋がります。

6. ホストOSで``curl localhost:8080``を実行してください。**Welcome to nginx**が``表示される``を確認してください。

このように、コンテナ起動時にホストのポートとコンテナのポートをつなげることができます。ちなみに、このとき指定したポートは専有するため、同じホストOSのポートは使いまわそうとするとコンテナが起動できません。

7. ``nginx:1.19.2``のイメージを使いコンテナをもう1つバックグラウンドで実行してください。コンテナの80をホストOSの8080に接続してください。以下の様なエラーがでることを確認してください。
   ```
   docker: Error response from daemon: driver failed programming external connectivity on endpoint sharp_tereshkova (ce0ac9fe75e72dda0cbceacd1a7994574710d1f15d8b2894c8e815d11e5c5da5): Bind for 0.0.0.0:8080 failed: port is already allocated.
   ```
8. ``nginx:1.19.2``のイメージを使いコンテナをもう1つバックグラウンドで実行してください。コンテナの80をホストOSの``8888``に接続してください。

9. コンテナの状態を確認してください。

10. ホストOSで``curl localhost:8888``を実行してください。**Welcome to nginx**が``表示される``を確認してください。

また、このようにホストOSのポートとつなげている状態であれば、ホストOS外の別のサーバからもホストOSのポートを指定してコンテナにアクセスできます。

11. ホストOSに到達可能な別サーバから``curl {ホストOS IP}:8080``を実行してください。**Welcome to nginx**が``表示される``ことを確認してください。

なお、隔離ネットワーク内のコンテナ同士も通信できます。ただし、この時の宛先ポートはホストOSに接続しているポートではなく、コンテナの待受ポートを指定します。

12. 結果がわかりやすくなるように各コンテナの``/usr/share/nginx/html/index.html``をそれぞれのコンテナとわかるように編集してください。(ヒント：コンテナに追加コマンドを発行するのは[docker exec](http://docs.docker.jp/engine/reference/commandline/exec.html)を使います。)

13. 以下コマンドで各コンテナの隔離ネットワーク内のIPアドレスを確認してください。172.17.0.0/16アドレス帯のIPアドレスのはずです。
    ``` sh
    docker inspect {8080で公開しているCONTAINER ID} | grep IPAddress
    docker inspect {8888で公開しているCONTAINER ID} | grep IPAddress
    ```

14. 各コンテナからもう一方のコンテナのIPアドレスに対してcurlを実行してください。お互いに通信可能であることを確認してください。（ヒント：curlの結果が見ずらい場合はsh -c "curl -s {宛先}"の様に追加コマンドを指定すると良いです。）

15. 以下コマンドですべてのコンテナを削除してください。
    ``` sh
    docker rm -f `docker ps -a -q`
    ```

このように、隔離ネットワーク内のコンテナ同士は通信できます。なお、この隔離ネットワークはホストOSごとに作られるため、異なるホストOS間のコンテナは隔離ネットワークで通信できません。ホストOSをまたぐコンテナ間で通信するにはホストOSのポートに接続するか、コンテナオーケストレーションを使いましょう。

また、ネットワークについて注意があります。隔離ネットワークはデフォルトで172.17.0.0/16のアドレス帯を使います。もし、ホストOSが属するアドレス帯や、通信先のアドレス帯がこのアドレス帯（172.17.0.0/16）とバッティングすると正しく通信できなくなる恐れがあります。なので、``172.17.0.0/16が使用可能か確認し、場合によっては隔離ネットワークのアドレス帯変更も検討``しましょう。

---

[TOP](../README.md)   
前: [コンテナの起動](./container-run.md)  
前: [どこでも同じものが動くということ](./container-feature-reproducibility.md)（時間ある人向け）  
次: [コンテナにファイルシステムをマウント](./container-volume.md)  
